当然可以。要在生产环境中使用这套方案，并且做到高度可配置、易于维护，我们需要将“**规则**”（什么版式、找什么关键字、怎么找）与“**引擎**”（执行查找和解析的代码）完全分离。

我们将通过**JSON配置文件**来定义所有提取规则，Java代码则变成一个通用的、由JSON驱动的提取引擎。当版式变化时，您只需要修改JSON文件，而无需触碰一行Java代码。

---

### 最终目标

*   **开发人员**：编写一次通用的提取引擎。
*   **运维/业务人员**：当出现新版式或旧版式变更时，复制一个现有的JSON模板，修改里面的关键字和规则，然后部署，即可完成适配。

---

### 第一步：设计可配置的JSON模板结构

这是整个方案的核心。我们需要一个结构清晰的JSON文件来描述如何解析一种特定版式的发票。创建一个目录，例如 `config/invoice-templates/`，用于存放所有模板。

**`beijing-tongzhou-hospital-template.json` (模板示例):**

```json
{
  "templateName": "北京市通州区中医医院医疗发票",
  "identifiers": [
    "北京市通州区中医医院",
    "医疗门诊收费票据"
  ],
  "fields": [
    {
      "fieldName": "payer",
      "keywords": ["交款人:", "交款人"],
      "strategy": "SAME_LINE",
      "options": {
        "trimChars": ": "
      }
    },
    {
      "fieldName": "invoiceNumber",
      "keywords": ["票据号码:", "票据号码"],
      "strategy": "SAME_LINE",
      "options": {
        "trimChars": ": "
      }
    },
    {
      "fieldName": "totalAmount",
      "keywords": ["金额合计(小写)"],
      "strategy": "SAME_LINE",
      "options": {
        "trimChars": "￥: ",
        "valuePattern": "[0-9.]+"
      }
    },
    {
      "fieldName": "businessId",
      "keywords": ["业务流水号:"],
      "strategy": "BELOW",
      "options": {
        "maxLinesBelow": 2,
        "stopAtKeywords": ["病历号:"]
      }
    },
    {
      "fieldName": "hospitalName",
      "keywords": ["收款单位"],
      "strategy": "AREA",
      "options": {
         "x_start": 100,
         "y_start": 150,
         "width": 300,
         "height": 50
      }
    }
  ]
}
```

**JSON字段解释:**

*   `templateName`: 模板的可读名称。
*   `identifiers`: **关键字段**。引擎会通过检查PDF内容是否**同时包含**这里所有的字符串，来决定是否应用此模板。这是实现版式自动识别的基础。
*   `fields`: 一个包含所有待提取字段规则的数组。
    *   `fieldName`: 您系统里希望保存的字段名，如 `payer`。
    *   `keywords`: 关键字列表。引擎会依次尝试列表中的每个关键字。
    *   `strategy`: **核心提取策略**。
        *   `SAME_LINE`: 在关键字同行向右查找。
        *   `BELOW`: 在关键字下方查找。
        *   `AREA`: 在页面的一个绝对坐标区域内查找（用于处理没有关键字，但位置固定的信息）。
    *   `options`: 策略的详细配置。
        *   `trimChars`: 找到值后，需要从开头剔除的字符（如冒号、空格、货币符号）。
        *   `valuePattern`: 一个正则表达式，用于从找到的字符串中再次提纯，例如只取数字。
        *   `maxLinesBelow`: `BELOW`策略下，最多向下查找多少行。
        *   `stopAtKeywords`: `BELOW`策略下，遇到这些关键字就停止查找。
        *   `x_start`, `y_start`, `width`, `height`: `AREA`策略的矩形坐标。

---

### 第二步：构建健壮的Java代码框架

现在，我们来编写读取JSON配置并执行提取的通用Java引擎。

#### 1. 定义与JSON对应的Java类 (DTOs)

使用 Jackson 或 Gson 库可以轻松地将JSON映射为Java对象。

```java
// 使用Lombok简化代码，也可以手动添加getter/setter
import lombok.Data;
import java.util.List;
import java.util.Map;

@Data
public class InvoiceTemplate {
    private String templateName;
    private List<String> identifiers;
    private List<FieldDefinition> fields;
}

@Data
public class FieldDefinition {
    private String fieldName;
    private List<String> keywords;
    private String strategy;
    private Map<String, Object> options;
}
```

#### 2. 模板仓库 (Template Repository)

这个类负责加载所有JSON模板，并根据PDF内容找到匹配的模板。

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class TemplateRepository {
    private final List<InvoiceTemplate> templates = new ArrayList<>();
    private final ObjectMapper objectMapper = new ObjectMapper();

    public TemplateRepository(String templatesDirectoryPath) throws IOException {
        File dir = new File(templatesDirectoryPath);
        File[] templateFiles = dir.listFiles((d, name) -> name.endsWith(".json"));
        if (templateFiles != null) {
            for (File file : templateFiles) {
                templates.add(objectMapper.readValue(file, InvoiceTemplate.class));
            }
        }
    }

    public InvoiceTemplate findTemplateFor(String pdfTextContent) {
        for (InvoiceTemplate template : templates) {
            boolean allIdentifiersFound = true;
            for (String identifier : template.getIdentifiers()) {
                if (!pdfTextContent.contains(identifier)) {
                    allIdentifiersFound = false;
                    break;
                }
            }
            if (allIdentifiersFound) {
                return template; // 找到了匹配的模板
            }
        }
        return null; // 没有找到匹配的模板
    }
}
```

#### 3. 核心处理器 (InvoiceProcessor)

这是驱动一切的主引擎。它不再包含任何硬编码的字段名或正则表达式。

```java
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.text.TextPosition;

import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class InvoiceProcessor {

    private final TemplateRepository templateRepository;
    // 实际项目中，这里应该用策略模式注入不同的Strategy实现
    // private final Map<String, ExtractionStrategy> strategies; 

    public InvoiceProcessor(String templatesPath) throws IOException {
        this.templateRepository = new TemplateRepository(templatesPath);
    }

    public Map<String, String> process(File pdfFile) throws IOException {
        Map<String, String> extractedData = new HashMap<>();

        try (PDDocument document = PDDocument.load(pdfFile)) {
            // 1. 提取带位置的文本和纯文本
            TextPositionExtractor extractor = new TextPositionExtractor();
            extractor.setStartPage(1);
            extractor.setEndPage(1); // 简化为第一页
            String pdfText = extractor.getText(document);
            List<TextPosition> allTextPositions = extractor.getTextPositions();

            // 2. 查找匹配的模板
            InvoiceTemplate template = templateRepository.findTemplateFor(pdfText);
            if (template == null) {
                System.out.println("没有找到适用于 " + pdfFile.getName() + " 的模板。");
                // 在生产中，这里可以把任务标记为“需要人工处理”或“进入二级AI处理”
                return extractedData;
            }
             System.out.println("使用模板: " + template.getTemplateName());

            // 3. 遍历模板中的字段并执行提取
            for (FieldDefinition field : template.getFields()) {
                // 这是一个简化的实现，实际应使用策略模式
                String value = null;
                if ("SAME_LINE".equals(field.getStrategy())) {
                    // 调用我们之前写的findValueOnSameLine，并传入options
                    // value = SameLineStrategy.extract(...)
                } else if ("BELOW".equals(field.getStrategy())) {
                    // 调用BELOW策略的实现
                } else if ("AREA".equals(field.getStrategy())) {
                    // 调用AREA策略的实现
                }
                
                if (value != null) {
                    extractedData.put(field.getFieldName(), value);
                }
            }
        }
        return extractedData;
    }
    
    public static void main(String[] args) throws IOException {
        InvoiceProcessor processor = new InvoiceProcessor("config/invoice-templates");
        File file = new File("11060125_0064077272.pdf");
        Map<String, String> data = processor.process(file);
        
        data.forEach((key, value) -> System.out.println(key + ": " + value));
    }
}
```
**注意**：为了清晰，`process`方法中的策略调用被简化了。在完整的生产级代码中，您会使用**策略设计模式（Strategy Design Pattern）**，将`SAME_LINE`、`BELOW`等逻辑分别封装到独立的类中，由`InvoiceProcessor`根据`field.getStrategy()`的值来动态调用。

---

### 第三步：目录结构与部署

您的项目最终会形成这样的结构：

```
.
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/yourcompany/invoice/
│   │   │       ├── dto/
│   │   │       │   ├── InvoiceTemplate.java
│   │   │       │   └── FieldDefinition.java
│   │   │       ├── strategy/           // 策略模式的实现
│   │   │       │   ├── ExtractionStrategy.java (Interface)
│   │   │       │   ├── SameLineStrategy.java
│   │   │       │   └── ...
│   │   │       ├── InvoiceProcessor.java
│   │   │       ├── TemplateRepository.java
│   │   │       └── TextPositionExtractor.java
│   │   └── resources/
│   │       └── log4j2.xml
├── config/
│   └── invoice-templates/
│       ├── beijing-tongzhou-hospital-template.json
│       └── another-hospital-template.json
├── target/
│   └── your-app.jar
└── pom.xml
```

部署时，您将Java代码打包成一个jar文件，`config`目录作为外部配置与jar包一起放置。这样，您可以随时增、删、改`config`目录下的JSON文件，然后重启服务（或者实现热加载），即可应用新的规则。

---

### 第四步：工作流程与持续维护

**当出现一个新的发票版式时，您的工作流程将变为：**

1.  **分析**：打开新的PDF，找到几个独一无二的、基本不会变的文本作为`identifiers`（例如医院全名+“收费票据”字样）。
2.  **复制**：复制一个最相似的现有JSON模板文件，重命名它。
3.  **修改**：
    *   更新`templateName`和`identifiers`。
    *   逐个检查`fields`。对于每个字段：
        *   关键字变了吗？（例如“票据号码”变成了“发票NO.”） -> 修改`keywords`列表。
        *   值的相对位置变了吗？（例如从同行变成了下一行） -> 修改`strategy`。
        *   提取出的值需要额外清理吗？ -> 调整`options`。
4.  **部署**：将新的JSON文件放入`config/invoice-templates`目录。
5.  **测试**：用新的PDF文件运行程序，验证所有字段是否正确提取。

通过这种方式，您将发票解析从一个**编码任务**转变为了一个**配置任务**，极大地提高了生产环境中的响应速度和可维护性。